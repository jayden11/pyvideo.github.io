<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="http://pyvideo.org/" rel="alternate"></link><link href="http://pyvideo.org/feeds/tag_zeromq.atom.xml" rel="self"></link><id>http://pyvideo.org/</id><updated>2013-10-15T00:00:00+00:00</updated><entry><title>PyGotham 2011: Real-time Web: Gevent and Socket.io</title><link href="http://pyvideo.org/pygotham-2011/pygotham-2011-real-time-web-gevent-and-socketi.html" rel="alternate"></link><published>1990-01-01T00:00:00+00:00</published><updated>1990-01-01T00:00:00+00:00</updated><author><name>Richard D. Copeland, Jr.</name></author><id>tag:pyvideo.org,1990-01-01:pygotham-2011/pygotham-2011-real-time-web-gevent-and-socketi.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;There has been a lot of talk lately about how Node.js enables the
real-time web, but did you know you can do the same thing with Python?
This talk will show you how to use Gevent, ZeroMQ, and Socket.io to
build portable Python- powered real-time web applications.&lt;/p&gt;
</summary><category term="gevent"></category><category term="pygotham"></category><category term="pygotham2011"></category><category term="real-time"></category><category term="socket.io"></category><category term="web"></category><category term="zeromq"></category></entry><entry><title>Vintage 1978 Superboard II hacking with some Python3 and ZeroMQ</title><link href="http://pyvideo.org/chipy/vintage-1978-superboard-ii-hacking-with-some-pyth.html" rel="alternate"></link><published>2011-01-13T00:00:00+00:00</published><updated>2011-01-13T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2011-01-13:chipy/vintage-1978-superboard-ii-hacking-with-some-pyth.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;I'm not sure if we're still looking for talks on Thursday, but if so,
I'd like to volunteer to give a talk about using Python to do some
retro-computing hacking involving my vintage 1978 Superboard II. It's
not exactly robotics, but it involves hardware and a lot of low-level
hacking (along with some Python3 and ZeroMQ thrown in for good measure
;-).&lt;/p&gt;
</summary><category term="chipy"></category><category term="cool"></category><category term="python3"></category><category term="zeromq"></category></entry><entry><title>Implementing distributed applications using ZeroMQ, Python and other bad guys...</title><link href="http://pyvideo.org/europython-2011/implementing-distributed-applications-using-zerom.html" rel="alternate"></link><published>2011-07-13T00:00:00+00:00</published><updated>2011-07-13T00:00:00+00:00</updated><author><name>Francesco Crippa</name></author><id>tag:pyvideo.org,2011-07-13:europython-2011/implementing-distributed-applications-using-zerom.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Francesco Crippa - 24 June 2011 in &amp;quot;Track Spaghetti&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Cloud Computing and Large Scale environments require sometime
applications based on complex and distributed architectures… and this
usually means a huge overhead in the design and confusion out of control
in the code (network wise race conditions, single points of failure and
so on)&lt;/p&gt;
&lt;p&gt;Introducing elements like *MQ and IPC frameworks in this kind of
applications is the only way to reduce the complexity and enable a fluid
design (in other words: mess-under-control)&lt;/p&gt;
&lt;p&gt;The talk is focused on describing how to design a distributed
application in different scenarios, using ZeroMQ (a modern broker-less
MQ system) as core framework, with examples and demos.&lt;/p&gt;
</summary><category term="design"></category><category term="distributed"></category><category term="zeromq"></category></entry><entry><title>Designing and Testing PyZMQ Applications</title><link href="http://pyvideo.org/pycon-de-2012/designing-and-testing-pyzmq-applications.html" rel="alternate"></link><published>2012-10-31T00:00:00+00:00</published><updated>2012-10-31T00:00:00+00:00</updated><author><name>Stefan Scherfke</name></author><id>tag:pyvideo.org,2012-10-31:pycon-de-2012/designing-and-testing-pyzmq-applications.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;PyZMQ ist eine mächtige aber dennoch einfach zu benutzende
Netzwerkbibliothek.&lt;/p&gt;
&lt;p&gt;Neben ZeroMQ’s und PyZMQ’s ausführlicher Dokumentation existieren auch
einige&lt;/p&gt;
&lt;p&gt;gute Tutorials. Über einfache Beispiele oder allgemeine
System-Architekturen&lt;/p&gt;
&lt;p&gt;gehen sie jedoch oft nicht hinaus.&lt;/p&gt;
&lt;p&gt;In diesem Vortrag werden daher Wege gezeigt, wie größere
PyZMQ-Anwendungen&lt;/p&gt;
&lt;p&gt;entworfen und getestet werden können. Behandelt werden dabei neben
Unit-Tests&lt;/p&gt;
&lt;p&gt;auch Prozess- und System-Tests.&lt;/p&gt;
&lt;p&gt;Der Vortrag basiert auf den Erfahrungen, die der Autor bei der
Entwicklung&lt;/p&gt;
&lt;p&gt;eines verteilten Simulations-Frameworks gemacht hat.&lt;/p&gt;
</summary><category term="application design"></category><category term="ømq"></category><category term="process tests"></category><category term="pyzmq"></category><category term="system tests"></category><category term="testing"></category><category term="unit tests"></category><category term="zeromq"></category></entry><entry><title>BACARDI - Ein Katalog für Raumfahrtrückstände</title><link href="http://pyvideo.org/pycon-de-2013/bacardi-ein-katalog-fur-raumfahrtruckstande.html" rel="alternate"></link><published>2013-10-15T00:00:00+00:00</published><updated>2013-10-15T00:00:00+00:00</updated><author><name>Michael Meinel</name></author><id>tag:pyvideo.org,2013-10-15:pycon-de-2013/bacardi-ein-katalog-fur-raumfahrtruckstande.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Das Thema Weltraumschrott tritt vermehrt in die Öffentlichkeit, denn nur
wenn jetzt das Augenmerk der raumfahrenden Nationen darauf gerichtet
wird, werden wir auch in Zukunft zu den Sternen reisen können. Die
Grundlage für eine nachhaltige Raumfahrtstrategie ist die Beobachtung
und Katalogisierung der Raumfahrtrückstände für die Planung und
Durchführung von Missionen. Am Deutschen Zentrum für Luft- und Raumfahrt
e.V. entsteht derzeit der Backend Catalog for Relational Debris
Information (BACARDI) als Technologiedemonstrator zum Umgang mit großen
Datenmengen.&lt;/p&gt;
&lt;p&gt;Die Python-Software kombiniert dazu moderne Technologien wie ZeroMQ und
Protocol Buffers zu einem flexiblen, skalierbaren Gesamtsystem, das in
der Lage sein soll, den wachsenden Ressourcenansprüchen zu genügen. Dank
der plattformunabhängigen Schnittstellen können Komponenten später auch
in anderen Programmiersprachen wie C, C# oder Java angebunden werden.&lt;/p&gt;
</summary><category term="middleware"></category><category term="protocol buffers"></category><category term="skalierbar"></category><category term="space debris"></category><category term="weltraumschrott"></category><category term="zeromq"></category></entry></feed>
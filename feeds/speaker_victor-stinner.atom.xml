<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="http://pyvideo.org/" rel="alternate"></link><link href="http://pyvideo.org/feeds/speaker_victor-stinner.atom.xml" rel="self"></link><id>http://pyvideo.org/</id><updated>2017-05-19T00:00:00+00:00</updated><entry><title>How to run a stable benchmark</title><link href="http://pyvideo.org/fosdem-2017/how-to-run-a-stable-benchmark.html" rel="alternate"></link><published>2017-02-05T00:00:00+00:00</published><updated>2017-02-05T00:00:00+00:00</updated><author><name>Victor Stinner</name></author><id>tag:pyvideo.org,2017-02-05:fosdem-2017/how-to-run-a-stable-benchmark.html</id><summary type="html"></summary></entry><entry><title>Optimizations which made Python 3.6 faster than Python 3.5</title><link href="http://pyvideo.org/pycon-us-2017/optimizations-which-made-python-36-faster-than-python-35.html" rel="alternate"></link><published>2017-05-19T00:00:00+00:00</published><updated>2017-05-19T00:00:00+00:00</updated><author><name>Victor Stinner</name></author><id>tag:pyvideo.org,2017-05-19:pycon-us-2017/optimizations-which-made-python-36-faster-than-python-35.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Various optimizations made Python 3.6 faster than Python 3.5. Let's see
in detail what was done and how.&lt;/p&gt;
&lt;p&gt;Python 3.6 is faster than any other Python version on many benchmarks.
We will see results of the Python benchmark suite on Python 2.7, 3.5 and
3.6.&lt;/p&gt;
&lt;p&gt;The bytecode format and instructions to call functions were redesign to
run bytecode faster.&lt;/p&gt;
&lt;p&gt;A new C calling convention, called &amp;quot;fast call&amp;quot;, was introduced to avoid
temporary tuple and dict. The way Python parses arguments was also
optimized using a new internal cache.&lt;/p&gt;
&lt;p&gt;Operations on bytes and encodes like UTF-8 were optimized a lot thanks
to a new API to create bytes objects. The API allows very efficient
optimizations and reduces memory reallocations.&lt;/p&gt;
&lt;p&gt;Some parts of asyncio were rewritten in C to speedup code up to 25%. The
PyMem_Malloc() function now also uses the fast pymalloc allocator also
giving tiny speedup for free.&lt;/p&gt;
&lt;p&gt;Finally, we will see optimization projects for Python 3.7: use fast
calls in more cases, speed up method calls, a cache on opcodes, a cache
on global variables.&lt;/p&gt;
</summary></entry><entry><title>asyncio community, one year later</title><link href="http://pyvideo.org/europython-2015/asyncio-community-one-year-later.html" rel="alternate"></link><published>2015-08-02T00:00:00+00:00</published><updated>2015-08-02T00:00:00+00:00</updated><author><name>Victor Stinner</name></author><id>tag:pyvideo.org,2015-08-02:europython-2015/asyncio-community-one-year-later.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Victor Stinner - asyncio community, one year later
[EuroPython 2015]
[22 July 2015]
[Bilbao, Euskadi, Spain]&lt;/p&gt;
&lt;p&gt;The asyncio project was officially launched with the release of Python
3.4 in March 2014. The project was public before that under the name
&amp;quot;tulip&amp;quot;. asyncio is just a core network library, it requires third
party library to be usable for common protocols. One year later,
asyncio has a strong community writing libraries on top of it.&lt;/p&gt;
&lt;p&gt;The most advanced library is aiohttp which includes a complete HTTP
client but also a HTTP server. There are also libraries to access
asynchronously the file system, resolve names with DNS, have variables
local to tasks, read-write locks, etc. There are clients for AMQP,
Asterisk, ElasticSearch, IRC, XMPP (Jabber), etc. (and even an IRC
server!). There are asynchronous drivers for all common databases, and
even for some ORMs. As expected, there are tons of new web frameworks
based on asyncio. It's also possible to plug asyncio into Gtk, Qt,
gevent, eventlet, gunicorn, tornado, etc.&lt;/p&gt;
&lt;p&gt;I will also discuss use cases of asyncio in production and benchmarks.
Spoiler: asyncio is not slow.&lt;/p&gt;
&lt;p&gt;The asyncio library also evolved to become more usable: it has a
better documentation, is easier to debug and has a few new functions.
There is also a port to Python 2: trollius.&lt;/p&gt;
</summary></entry><entry><title>Core Developers' Panel</title><link href="http://pyvideo.org/europython-2016/core-developers-panel.html" rel="alternate"></link><published>2016-08-01T00:00:00+00:00</published><updated>2016-08-01T00:00:00+00:00</updated><author><name>Victor Stinner</name></author><id>tag:pyvideo.org,2016-08-01:europython-2016/core-developers-panel.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Victor Stinner/Larry Hastings/Christian Heimes/Yury Selivanov - Core Developers' Panel
[EuroPython 2016]
[20 July 2016]
[Bilbao, Euskadi, Spain]&lt;/p&gt;
&lt;p&gt;Q&amp;amp;A session with Python core developers&lt;/p&gt;
</summary></entry><entry><title>FAT Python: a new static optimizer for Python 3.6</title><link href="http://pyvideo.org/europython-2016/fat-python-a-new-static-optimizer-for-python-36.html" rel="alternate"></link><published>2016-08-01T00:00:00+00:00</published><updated>2016-08-01T00:00:00+00:00</updated><author><name>Victor Stinner</name></author><id>tag:pyvideo.org,2016-08-01:europython-2016/fat-python-a-new-static-optimizer-for-python-36.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Victor Stinner - FAT Python: a new static optimizer for Python 3.6
[EuroPython 2016]
[20 July 2016]
[Bilbao, Euskadi, Spain]
(&lt;a class="reference external" href="https://ep2016.europython.eu//conference/talks/fat-python-a-new-static-optimizer-for-python-36"&gt;https://ep2016.europython.eu//conference/talks/fat-python-a-new-static-optimizer-for-python-36&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;The Python language is hard to optimize. Let's see how guards checked
at runtime allows to implement new optimizations without breaking the
Python semantic.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;(Almost) everything in Python is mutable which makes Python a language
very difficult to optimize. Most optimizations rely on assumptions,
for example that builtin functions are not replaced. Optimizing Python
requires a trigger to disable optimization when an assumption is no
more true. FAT Python exactly does that with guards checked at
runtime. For example, an optimization relying on the builtin len()
function is disabled when the function is replaced.&lt;/p&gt;
&lt;p&gt;Guards allows to implement various optimizations. Examples: loop
unrolling (duplicate the loop body), constant folding (propagates
constants), copy builtins to constants, remove unused local variables,
etc.&lt;/p&gt;
&lt;p&gt;FAT Python implements guards and an optimizer rewriting the Abstract
Syntax Tree (AST). The optimizer is implemented in Python so it's easy
to enhance it and implement new optimizations.&lt;/p&gt;
&lt;p&gt;FAT Python uses a static optimizer, it is less powerful than a JIT
compiler like PyPy with tracing, but it was written to be integrated
into CPython.&lt;/p&gt;
&lt;p&gt;I wrote 3 PEP (509, 510, 511) targeting Python 3.6. Some changes to
support FAT Python have already been merged into Python 3.6.&lt;/p&gt;
&lt;p&gt;We will also see other pending patches to optimize CPython core, and
the bytecode project which allows to modify bytecode, it also includes
a peephole optimizer written in pure Python.&lt;/p&gt;
&lt;p&gt;Links:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://faster-cpython.readthedocs.org/fat_python.html"&gt;http://faster-cpython.readthedocs.org/fat_python.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://fatoptimizer.readthedocs.org/"&gt;http://fatoptimizer.readthedocs.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://bytecode.readthedocs.org/"&gt;http://bytecode.readthedocs.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</summary></entry><entry><title>Traquer les fuites mémoire en Python</title><link href="http://pyvideo.org/pycon-fr-2013/traquer-les-fuites-memoire-en-python.html" rel="alternate"></link><published>2013-11-30T00:00:00+00:00</published><updated>2013-11-30T00:00:00+00:00</updated><author><name>Victor Stinner</name></author><id>tag:pyvideo.org,2013-11-30:pycon-fr-2013/traquer-les-fuites-memoire-en-python.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Les fuites mémoire en Python ne peuvent pas être analysées avec les
outils traditionnels car Python repose sur les compteurs de référence.
Je vais présenter des outils spécifiques à Python pour vous aider à
localiser vos fuites mémoires.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Consommation globale du processus (mémoire RSS)&lt;/li&gt;
&lt;li&gt;Comprendre les cycles de référence&lt;/li&gt;
&lt;li&gt;Générer une image représentant les liens entre les objets&lt;/li&gt;
&lt;li&gt;Utilisation de gc.get_objects() et calcul manuel de la taille des
objets&lt;/li&gt;
&lt;li&gt;Tracer les allocations mémoires à leur création&lt;/li&gt;
&lt;li&gt;PEP 445: Add new APIs to customize Python memory allocators
implementée dans Python 3.4&lt;/li&gt;
&lt;li&gt;Projet pytracemalloc&lt;/li&gt;
&lt;/ul&gt;
</summary></entry><entry><title>Status of Unicode in Python 3</title><link href="http://pyvideo.org/pycon-us-2011/pycon-2011--status-of-unicode-in-python-3.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Victor Stinner</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--status-of-unicode-in-python-3.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Introduced in Python 2.0, unicode became the default string type in
Python 3.0. It took 8 years to switch to unicode, and since Python 3.0,
a lot of bugs has been fixed. The switch to unicode opened many
questions. Should Python support both bytes and characters for
filenames? What to do with undecodable bytes? etc.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The talk will focus on the recent issues fixed in Python 3.1 and 3.2:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use the PEP 383 (error handler to store undecodable bytes) everywhere&lt;/li&gt;
&lt;li&gt;Encoding of the command line arguments: utf-8 on Mac OS X, locale
encoding on UNIX/BSD, unicode on Windows&lt;/li&gt;
&lt;li&gt;Environment variables: creation of os.environb&lt;/li&gt;
&lt;li&gt;Filenames: huge work to support the PEP 383 everywhere, creation of
os.fsencode() and os.fsdecode()&lt;/li&gt;
&lt;li&gt;Python source code encoding: use tokenize.detect_encoding() instead
of the locale encoding&lt;/li&gt;
&lt;li&gt;some library examples: email, ftp, ...&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The talk will present not only the changes in Python, but also in the C
API.&lt;/p&gt;
</summary><category term="pycon"></category><category term="pycon2011"></category><category term="python3"></category><category term="unicode"></category></entry><entry><title>Track memory leaks in Python</title><link href="http://pyvideo.org/pycon-us-2014/track-memory-leaks-in-python.html" rel="alternate"></link><published>2014-04-13T00:00:00+00:00</published><updated>2014-04-13T00:00:00+00:00</updated><author><name>Victor Stinner</name></author><id>tag:pyvideo.org,2014-04-13:pycon-us-2014/track-memory-leaks-in-python.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Memory leaks in Python cannot be analyzed with traditional tools because
Python uses reference counters. I will present tools specific to Python
to help you to localize your memory leaks.&lt;/p&gt;
</summary></entry></feed>
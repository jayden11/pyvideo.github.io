<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="http://pyvideo.org/" rel="alternate"></link><link href="http://pyvideo.org/feeds/speaker_cesare-di-mauro.atom.xml" rel="self"></link><id>http://pyvideo.org/</id><updated>2015-06-09T00:00:00+00:00</updated><entry><title>Hacking PyLongObject on Python 3.2</title><link href="http://pyvideo.org/europython-2011/hacking-pylongobject-on-python-32.html" rel="alternate"></link><published>2011-07-13T00:00:00+00:00</published><updated>2011-07-13T00:00:00+00:00</updated><author><name>Cesare Di Mauro</name></author><id>tag:pyvideo.org,2011-07-13:europython-2011/hacking-pylongobject-on-python-32.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Cesare Di Mauro - 24 June 2011 in &amp;quot;Track Ravioli &amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Beginning with Python 3 the old integer (&amp;quot;int&amp;quot;) type has gone leaving
the place to &amp;quot;long&amp;quot;, which replaced it giving a unique, uniform type to
deal with integers. However longs need a more complex structure which
effectively dropped a bit of Python 3.x performance. Looking at their
implementation, an idea grown that can help to improve the situation on
common sceneries (using &amp;quot;short&amp;quot; integers). A slightly changed structure
will be presented and compared with the old PyIntObject and the current
Python 3.2 PyLongObject, along with some optimizations, thoughts, and
issues found on the road, which will show the effort required by such
change on a Python core element.&lt;/p&gt;
</summary><category term="hacking"></category></entry><entry><title>Writing an 8086 emulator</title><link href="http://pyvideo.org/pycon-italia-2015/writing-an-8086-emulator.html" rel="alternate"></link><published>2015-06-09T00:00:00+00:00</published><updated>2015-06-09T00:00:00+00:00</updated><author><name>Cesare Di Mauro</name></author><id>tag:pyvideo.org,2015-06-09:pycon-italia-2015/writing-an-8086-emulator.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;An 8086 emulator written in Python is presented. The talk gives a brief
introduction to the 8086 architecture, the pitfalls on emulating it, and
the challenge to have a working model ready to be quickly ported in C
(which is the final goal of the project). Some classes are presented
that try to “mimic” the C memory pointers handling, to make the port
easier. A set of APIs is shown, which are exposed to the emulator
“consumers” (applications, drivers, or kernels). Finally, some words are
spent about how testing is done and can be reused by the C version as
well.&lt;/p&gt;
</summary></entry></feed>
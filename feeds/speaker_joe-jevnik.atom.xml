<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="http://pyvideo.org/" rel="alternate"></link><link href="http://pyvideo.org/feeds/speaker_joe-jevnik.atom.xml" rel="self"></link><id>http://pyvideo.org/</id><updated>2017-05-19T00:00:00+00:00</updated><entry><title>Title Available On Request: An Introduction to Lazy Evaluation</title><link href="http://pyvideo.org/pycon-us-2017/title-available-on-request-an-introduction-to-lazy-evaluation.html" rel="alternate"></link><published>2017-05-19T00:00:00+00:00</published><updated>2017-05-19T00:00:00+00:00</updated><author><name>Joe Jevnik</name></author><id>tag:pyvideo.org,2017-05-19:pycon-us-2017/title-available-on-request-an-introduction-to-lazy-evaluation.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Lazy evaluation, also known as &amp;quot;call by need&amp;quot;, is an evaluation strategy
where values are produced only when needed. Lazy evaluation is the
opposite of eager evaluation, Python's normal evaluation model, where
functions are executed as seen and values are produced immediately.&lt;/p&gt;
&lt;p&gt;In this talk we will define lazy evaluation and contrast it with eager
evaluation. We will discuss tools that exist in Python for using lazy
evaluation and show how we can build on the primitives to better
represent computations. We will introduce common vocabulary for
discussing evaluation models, and compare different systems for
implementing lazy evaluation. Finally, we will discuss optimizations
that can be made to optimize lazily evaluated expressions.&lt;/p&gt;
</summary></entry><entry><title>How to Write and Debug C Extension Modules</title><link href="http://pyvideo.org/pycon-us-2017/how-to-write-and-debug-c-extension-modules.html" rel="alternate"></link><published>2017-05-17T00:00:00+00:00</published><updated>2017-05-17T00:00:00+00:00</updated><author><name>Joe Jevnik</name></author><id>tag:pyvideo.org,2017-05-17:pycon-us-2017/how-to-write-and-debug-c-extension-modules.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The CPython interpreter allows us implement modules in C for performance
critical code or to interface with external libraries while presenting
users with a high level Python API. This tutorial will teach you how to
leverage to power of C in your Python projects.&lt;/p&gt;
&lt;p&gt;We will start by explaining the C representation of Python objects and
how to manipulate them from within C. We will then move on to
implementing functions in C for use in Python. We will discuss reference
counting and correct exception handling. We will also talk about how to
package and build your new extension module so that it may be shared on
PyPI. (We will only be covering building extension modules on GNU/Linux
and OSX, not Windows).&lt;/p&gt;
&lt;p&gt;After the break, we will show how to implement a new type in C. This
will cover how to hook into various protocols and properly support
cyclic garbage collection. We will also discuss techniques for debugging
C extension modules with gdb using the CPython gdb extension.&lt;/p&gt;
</summary></entry><entry><title>Playing with Python Bytecode</title><link href="http://pyvideo.org/pygotham-2016/playing-with-python-bytecode.html" rel="alternate"></link><published>2016-07-16T00:00:00+00:00</published><updated>2016-07-16T00:00:00+00:00</updated><author><name>Scott Sanderson</name></author><id>tag:pyvideo.org,2016-07-16:pygotham-2016/playing-with-python-bytecode.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Ever wondered what Python is actually doing when it executes your code? Want to learn to hand-craft artisanal Python bytecode? In this talk, we explain CPython's internal code representation, and we demonstrate techniques for modifying code objects for fun and profit.&lt;/p&gt;
</summary><category term="bytecode"></category></entry><entry><title>Playing with Python Bytecode</title><link href="http://pyvideo.org/pycon-us-2016/scott-sanderson-joe-jevnik-playing-with-python-bytecode-pycon-2016.html" rel="alternate"></link><published>2016-05-31T00:00:00+00:00</published><updated>2016-05-31T00:00:00+00:00</updated><author><name>Scott Sanderson</name></author><id>tag:pyvideo.org,2016-05-31:pycon-us-2016/scott-sanderson-joe-jevnik-playing-with-python-bytecode-pycon-2016.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Speakers: Scott Sanderson, Joe Jevnik&lt;/p&gt;
&lt;p&gt;Ever wondered what Python is actually doing when it executes your code?  Want to learn to hand-craft artisanal Python bytecode?  In this talk, we explain CPython's internal code representation, and we demonstrate techniques for modifying code objects for fun and profit.&lt;/p&gt;
&lt;p&gt;Slides can be found at: &lt;a class="reference external" href="https://speakerdeck.com/pycon2016"&gt;https://speakerdeck.com/pycon2016&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/PyCon/2016-slides"&gt;https://github.com/PyCon/2016-slides&lt;/a&gt;&lt;/p&gt;
</summary></entry></feed>
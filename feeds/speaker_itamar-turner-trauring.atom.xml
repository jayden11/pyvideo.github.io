<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="http://pyvideo.org/" rel="alternate"></link><link href="http://pyvideo.org/feeds/speaker_itamar-turner-trauring.atom.xml" rel="self"></link><id>http://pyvideo.org/</id><updated>2017-05-19T00:00:00+00:00</updated><entry><title>Big picture software testing: unit testing, Lean Startup, and everything in-between</title><link href="http://pyvideo.org/pycon-us-2017/big-picture-software-testing-unit-testing-lean-startup-and-everything-in-between.html" rel="alternate"></link><published>2017-05-19T00:00:00+00:00</published><updated>2017-05-19T00:00:00+00:00</updated><author><name>Itamar Turner-Trauring</name></author><id>tag:pyvideo.org,2017-05-19:pycon-us-2017/big-picture-software-testing-unit-testing-lean-startup-and-everything-in-between.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;There are many ways you can test your software: unit testing, manual
testing, end-to-end testing, and so forth. Take a step back and you'll
discover even more form of testing, many of them very different in their
goals: A/B testing, say, where you see which of two versions of your
website results in more signups or ad clicks.&lt;/p&gt;
&lt;p&gt;How do these forms of testing differ, how do they relate to each other?
How do you choose which kind of testing to pursue, given limited time
and resources? How do you deal with strongly held yet opposite views
arguing either that a particular kind of testing is essential or that
it's a waste time?&lt;/p&gt;
&lt;p&gt;This talk will provide you with a model, a way to organize all forms of
testing and understand what exactly they provide, and why. Once you
understand the model you will be able to choose the right form of
testing for &lt;em&gt;your&lt;/em&gt; situation and goals.&lt;/p&gt;
</summary></entry><entry><title>Intermediate Twisted: Test-Driven Networking Software</title><link href="http://pyvideo.org/pycon-us-2013/intermediate-twisted-test-driven-networking-soft.html" rel="alternate"></link><published>2013-03-14T00:00:00+00:00</published><updated>2013-03-14T00:00:00+00:00</updated><author><name>Itamar Turner-Trauring</name></author><id>tag:pyvideo.org,2013-03-14:pycon-us-2013/intermediate-twisted-test-driven-networking-soft.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Writing tests for networking code presents special challenges, which
Twisted tries to address. In this tutorial you will implement a toy HTTP
server using test-first methodology: first the tests are written, and
then the code. You will learn how to write well-tested network
applications using Twisted, and the general virtues of doing test-driven
development.&lt;/p&gt;
</summary><category term="tutorial"></category></entry><entry><title>A Beginner's Guide to Test-driven Development</title><link href="http://pyvideo.org/pycon-us-2015/a-beginners-guide-to-test-driven-development.html" rel="alternate"></link><published>2015-04-11T00:00:00+00:00</published><updated>2015-04-11T00:00:00+00:00</updated><author><name>Itamar Turner-Trauring</name></author><id>tag:pyvideo.org,2015-04-11:pycon-us-2015/a-beginners-guide-to-test-driven-development.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Software is maintained by humans with limited memory and an unfortunate
tendency to make mistakes. Test-driven development (TDD) can help you
work around these design flaws by providing a permanent, automated
specification for your code. Learn how to implement TDD when bug fixing
and implementing new features and how this process will ensure your code
is correct both now and in the future.&lt;/p&gt;
</summary></entry></feed>
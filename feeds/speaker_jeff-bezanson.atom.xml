<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="http://pyvideo.org/" rel="alternate"></link><link href="http://pyvideo.org/feeds/speaker_jeff-bezanson.atom.xml" rel="self"></link><id>http://pyvideo.org/</id><updated>2012-07-18T00:00:00+00:00</updated><entry><title>Julia: A Fast Dynamic Language for Technical Computing</title><link href="http://pyvideo.org/scipy-2012/julia-a-fast-dynamic-language-for-technical-comp.html" rel="alternate"></link><published>2012-07-18T00:00:00+00:00</published><updated>2012-07-18T00:00:00+00:00</updated><author><name>Jeff Bezanson</name></author><id>tag:pyvideo.org,2012-07-18:scipy-2012/julia-a-fast-dynamic-language-for-technical-comp.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Julia is a dynamic language designed for technical applications and high
performance. Its design is based on a sophisticated but unobtrusive type
system, type inference, multiple dispatch instead of class-based OO, and
a code generator based on LLVM. These features work together to run
high-level code efficiently even without type declarations. At the same
time, the type system provides useful expressiveness for designing
libraries, enables forms of metaprogramming not traditionally found in
dynamic languages, and creates the possibility of statically compiling
whole programs and libraries. This combination of high performance and
expressiveness makes it possible for most of Julia's standard library to
be written in Julia itself, with an interface to call existing C and
Fortran libraries.&lt;/p&gt;
&lt;p&gt;We will discuss some ways that Python and Julia can interoperate, and
compare Julia's current capabilities to Python and NumPy.&lt;/p&gt;
</summary><category term="General"></category></entry></feed>
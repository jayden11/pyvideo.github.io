<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>http://pyvideo.org/</link><description></description><lastBuildDate>Tue, 09 Jun 2015 00:00:00 +0000</lastBuildDate><item><title>Hacking PyLongObject on Python 3.2</title><link>http://pyvideo.org/europython-2011/hacking-pylongobject-on-python-32.html</link><description>&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Cesare Di Mauro - 24 June 2011 in &amp;quot;Track Ravioli &amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Beginning with Python 3 the old integer (&amp;quot;int&amp;quot;) type has gone leaving
the place to &amp;quot;long&amp;quot;, which replaced it giving a unique, uniform type to
deal with integers. However longs need a more complex structure which
effectively dropped a bit of Python 3.x performance. Looking at their
implementation, an idea grown that can help to improve the situation on
common sceneries (using &amp;quot;short&amp;quot; integers). A slightly changed structure
will be presented and compared with the old PyIntObject and the current
Python 3.2 PyLongObject, along with some optimizations, thoughts, and
issues found on the road, which will show the effort required by such
change on a Python core element.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cesare Di Mauro</dc:creator><pubDate>Wed, 13 Jul 2011 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2011-07-13:europython-2011/hacking-pylongobject-on-python-32.html</guid><category>hacking</category></item><item><title>Writing an 8086 emulator</title><link>http://pyvideo.org/pycon-italia-2015/writing-an-8086-emulator.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;An 8086 emulator written in Python is presented. The talk gives a brief
introduction to the 8086 architecture, the pitfalls on emulating it, and
the challenge to have a working model ready to be quickly ported in C
(which is the final goal of the project). Some classes are presented
that try to “mimic” the C memory pointers handling, to make the port
easier. A set of APIs is shown, which are exposed to the emulator
“consumers” (applications, drivers, or kernels). Finally, some words are
spent about how testing is done and can be reused by the C version as
well.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cesare Di Mauro</dc:creator><pubDate>Tue, 09 Jun 2015 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2015-06-09:pycon-italia-2015/writing-an-8086-emulator.html</guid></item></channel></rss>
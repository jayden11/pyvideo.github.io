<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>http://pyvideo.org/</link><description></description><lastBuildDate>Sat, 11 Mar 2017 00:00:00 +0000</lastBuildDate><item><title>How import works</title><link>http://pyvideo.org/pycon-sk-2016/how-import-works.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Every one of us has already used the &lt;tt class="docutils literal"&gt;import&lt;/tt&gt; statement. Do you know
what it actually does? How does it find the correct file using the
module name and how a text file becomes a module? Did you know that
Python can import from ZIP archives or run directories? Do you want to
find out how cyclic imports happen and how to avoid them?&lt;/p&gt;
&lt;p&gt;This talk will answer all of these questions.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Petr Viktorin</dc:creator><pubDate>Fri, 11 Mar 2016 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2016-03-11:pycon-sk-2016/how-import-works.html</guid></item><item><title>The Balance of Python</title><link>http://pyvideo.org/pycon-sk-2017/the-balance-of-python.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python successfully maintains a fine balance between being easy to learn and
useful for even large-scale projects.
This is achieved both through the design of the language, and through
the community.&lt;/p&gt;
&lt;p&gt;On the language design side, Python is built around a closely curated set
of mechanisms – iterators, attribute/item access, callables, context managers,
and so on.
I'll compare this set to languages like C, Lisp, Java, C++, and JavaScript,
and show why it works – and where it could be better.&lt;/p&gt;
&lt;p&gt;In design discussions around Python, the phrase &amp;quot;consenting adults&amp;quot; is
often repeated.
Python is designed to not prevent its users from doing anything.
You can fairly freely inspect classes or even monkeypatch as needed.
To balance this freedom, there is a vague, ever-changing notion of &amp;quot;Pythonic
code&amp;quot;, which is nevertheless quite successful in making the Python that
actual programmers use quite a strict language.
I'll share some insights about about how this balance works out, and how it
helped make Python the language – and community – that it is today.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Petr Viktorin</dc:creator><pubDate>Sat, 11 Mar 2017 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2017-03-11:pycon-sk-2017/the-balance-of-python.html</guid></item><item><title>Import Deep Dive</title><link>http://pyvideo.org/europython-2015/import-deep-dive.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Petr Viktorin - Import Deep Dive
[EuroPython 2015]
[24 July 2015]
[Bilbao, Euskadi, Spain]&lt;/p&gt;
&lt;p&gt;Whatever you need to do with Python, you can probably import a library
for it. But what exactly happens when you use that import statement?
How does a source file that you've installed or written become a
Python module
object, providing functions or classes for you to play with?&lt;/p&gt;
&lt;p&gt;While the import mechanism is relatively well-documented in the
reference and dozens of PEPs, sometimes even Python veterans are
caught by surprise. And some details are little-known: did you know
you can import from zip archives? Write CPython modules in C, or even
a dialect of Lisp? Or import from URLs (which might not be a good
idea)?&lt;/p&gt;
&lt;p&gt;This talk explains exactly what can happen when you use the import
statement – from the mundane machinery of searching PYTHONPATH through
subtle details of packages and import loops, to deep internals of
custom importers and C extension loading.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Petr Viktorin</dc:creator><pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2015-08-05:europython-2015/import-deep-dive.html</guid></item><item><title>Lightning Talks 2016-07-20</title><link>http://pyvideo.org/europython-2016/lightning-talks-2016-07-20.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Various speakers - Lightning Talks
[EuroPython 2016]
[20 July 2016]
[Bilbao, Euskadi, Spain]&lt;/p&gt;
&lt;p&gt;Lightning talks, presented by Harald Massa and Harry Percival&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Christopher Lozinski - blogory.org&lt;/li&gt;
&lt;li&gt;David Naranja &amp;amp; Maria Coetero - Random.random() online&lt;/li&gt;
&lt;li&gt;Petr Viktorin - PEPs 487 &amp;amp; 520 (*descriptors in 5 min)&lt;/li&gt;
&lt;li&gt;Anselm Linsnau - tuxcademy - Great training material - for free!&lt;/li&gt;
&lt;li&gt;Miroslav Pojman - PyOO - Control Open Office from Python&lt;/li&gt;
&lt;li&gt;Fabio Pliger - Jupyterlab&lt;/li&gt;
&lt;li&gt;Plethora - Python meets Industry - Data Challenge&lt;/li&gt;
&lt;li&gt;Adam Castle - Ripe Forum&lt;/li&gt;
&lt;li&gt;Florian Brühen - Crowdfunding&lt;/li&gt;
&lt;li&gt;Charlie Beeson - Running a Coding Cometition&lt;/li&gt;
&lt;li&gt;Pavlo  Andriychenko - Jupiter Tricks&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Christopher Lozinski</dc:creator><pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2016-08-01:europython-2016/lightning-talks-2016-07-20.html</guid><category>lightning talks</category></item><item><title>The Magic of Attribute Access</title><link>http://pyvideo.org/europython-2014/the-magic-of-attribute-access.html</link><description>&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Have you ever wondered how the &amp;quot;self&amp;quot; argument appears when you call a
method? Did you know there is a general mechanism behind it? Come learn
all about attributes and descriptors.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The first part of this talk will describe what exactly happens when you
read or write an attribute in Python.&lt;/p&gt;
&lt;p&gt;While this behavior is, of course, explained in the Python docs, more
precisely in the &lt;a class="reference external" href="http://docs.python.org/3/reference/datamodel.html"&gt;Data
model&lt;/a&gt; section and
&lt;a class="reference external" href="http://docs.python.org/3/howto/descriptor.html"&gt;related&lt;/a&gt;
&lt;a class="reference external" href="https://www.python.org/download/releases/2.3/mro/"&gt;writeups&lt;/a&gt;, the
documentation gives one a &amp;quot;bag of tools&amp;quot; and leaves combining them to
the reader.&lt;/p&gt;
&lt;p&gt;This talk, on the other hand, will present one chunk of functionality,
the attribute lookup, and show how its mechanisms and customization
options work together to provide the flexibility (and gotchas) Python
provides. The topics covered will be:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;method resolution order, with a nod to the C3 algorithm&lt;/li&gt;
&lt;li&gt;instance-, class-, and metaclass-level variables&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;__dict__&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;__slots__&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;data/non-data descriptors&lt;/li&gt;
&lt;li&gt;special methods (&lt;tt class="docutils literal"&gt;__getattr__&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;__getattribute__&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;__setattr__&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;__dir__&lt;/tt&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the second part of the talk, I will show how to use the customization
primitives explained before on several interesting and/or useful
examples:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A proxy object using &lt;tt class="docutils literal"&gt;__getattr__&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Generic desciptor - an ORM column sketch&lt;/li&gt;
&lt;li&gt;the rudimentary &lt;tt class="docutils literal"&gt;&amp;#64;property&lt;/tt&gt;, method, &lt;tt class="docutils literal"&gt;staticmethod&lt;/tt&gt; reimplemented
in pure Python (explained
&lt;a class="reference external" href="http://docs.python.org/3/howto/descriptor.html"&gt;here&lt;/a&gt; and
elsewhere), which lead to&lt;/li&gt;
&lt;li&gt;SQLAlchemy's
&lt;tt class="docutils literal"&gt;`&amp;#64;hybrid_proprerty&lt;/tt&gt; &amp;lt;&lt;a class="reference external" href="http://docs.sqlalchemy.org/en/rel_0_9/orm/extensions/hybrid.html"&gt;http://docs.sqlalchemy.org/en/rel_0_9/orm/extensions/hybrid.html&lt;/a&gt;&amp;gt;`__&lt;/li&gt;
&lt;li&gt;Pyramid's deceptively simple memoizing decorator,
&lt;tt class="docutils literal"&gt;`&amp;#64;reify&lt;/tt&gt; &amp;lt;&lt;a class="reference external" href="http://docs.pylonsproject.org/projects/pyramid/en/latest/api/decorator.html"&gt;http://docs.pylonsproject.org/projects/pyramid/en/latest/api/decorator.html&lt;/a&gt;&amp;gt;`__&lt;/li&gt;
&lt;li&gt;An &lt;a class="reference external" href="https://gist.github.com/encukou/9789993"&gt;&amp;quot;Unpacked&amp;quot; tuple
properties&lt;/a&gt; example to
drive home the idea that descriptors can do more than provide
attribute access (and mention weak dicts as a way to non-intrusively
store data on an object)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(These are subject to change as I compose the talk. Also some examples
may end up interleaved with the theory.)&lt;/p&gt;
&lt;p&gt;Hopefully I'll have time to conclude with a remark about how Python
manages to be a &amp;quot;simple language&amp;quot; despite having these relatively
complex mechanisms.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Petr Viktorin</dc:creator><pubDate>Tue, 22 Jul 2014 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2014-07-22:europython-2014/the-magic-of-attribute-access.html</guid></item></channel></rss>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="http://pyvideo.org/" rel="alternate"></link><link href="http://pyvideo.org/feeds/speaker_adam-harvey.atom.xml" rel="self"></link><id>http://pyvideo.org/</id><updated>2015-08-04T00:00:00+00:00</updated><entry><title>Four* non-cryptographic hash functions enter. One leaves.</title><link href="http://pyvideo.org/pycon-au-2015/four-non-cryptographic-hash-functions-enter-one.html" rel="alternate"></link><published>2015-08-04T00:00:00+00:00</published><updated>2015-08-04T00:00:00+00:00</updated><author><name>Adam Harvey</name></author><id>tag:pyvideo.org,2015-08-04:pycon-au-2015/four-non-cryptographic-hash-functions-enter-one.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;When you say “hash function” in a room full of Python developers, people
tend to think of the classics you get in hashlib: MD5, SHA-1, SHA-224,
SHA-256, SHA-384, SHA-512, SHA-OHGODPLEASESTOP, and the like —
cryptographic hash functions intended for cryptographic uses.&lt;/p&gt;
&lt;p&gt;There’s another world out there, though: non-cryptographic hashes.
Sometimes you just need to figure out if you’ve already seen a string or
structure. Sometimes you need a basic checksum. Sometimes you need a
hash that’s just fast and can fit into a 32 bit integer.&lt;/p&gt;
&lt;p&gt;I’ll run through the state of the art in the world of non-cryptographic
hashing — what your best options are, how they compare in terms of CPU
and memory usage, and how they work. Who takes it? Whose mixing function
reigns supreme?&lt;/p&gt;
&lt;p&gt;Let’s find out.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;I’m saying “four”, but realistically I’m going to cover as many
modern options as I can fit into the time available. Let’s say “four
plus two or minus one” in reality.&lt;/li&gt;
&lt;/ul&gt;
</summary></entry></feed>
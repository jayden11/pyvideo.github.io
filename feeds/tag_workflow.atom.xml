<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="http://pyvideo.org/" rel="alternate"></link><link href="http://pyvideo.org/feeds/tag_workflow.atom.xml" rel="self"></link><id>http://pyvideo.org/</id><updated>2016-07-14T00:00:00+00:00</updated><entry><title>Reproducible, One Button Workflows with the Jupyter Notebook &amp; Scons</title><link href="http://pyvideo.org/scipy-2016/reproducible-one-button-workflows-with-the-jupyter-notebook-scons-scipy-2016-jessica-hamrick.html" rel="alternate"></link><published>2016-07-14T00:00:00+00:00</published><updated>2016-07-14T00:00:00+00:00</updated><author><name>Jessica Hamrick</name></author><id>tag:pyvideo.org,2016-07-14:scipy-2016/reproducible-one-button-workflows-with-the-jupyter-notebook-scons-scipy-2016-jessica-hamrick.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What is the best way to develop analysis code in the Jupyter notebook, while managing complex dependencies between analyses? In this talk, I will introduce nbflow, which is a project that integrates a Python-based build system (SCons) with the Jupyter notebook, enabling researchers to easily build sophisticated,
complex analysis pipelines entirely within notebooks while still maintaining a &amp;quot;one-button workflow&amp;quot; in which all analyses can be executed, in the correct order, from a single command. I will show how nbflow can be applied to existing analyses and how it can be used to construct an analysis pipeline stretching the entire way from data cleaning, to computing statistics, to generating figures,
and even to automatically generating LaTeX commands that can be used in publications to format results without the risk of copy-and-paste error.&lt;/p&gt;
</summary><category term="SciPy 2016"></category><category term="jupyter"></category><category term="jupyter notebook"></category><category term="workflow"></category><category term="nbflow"></category></entry><entry><title>The development process of Python</title><link href="http://pyvideo.org/europython-2011/the-development-process-of-python.html" rel="alternate"></link><published>2011-07-13T00:00:00+00:00</published><updated>2011-07-13T00:00:00+00:00</updated><author><name>Ezio Melotti</name></author><id>tag:pyvideo.org,2011-07-13:europython-2011/the-development-process-of-python.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Ezio Melotti - 24 June 2011 in &amp;quot;Track Ravioli &amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python is an open source language, where everyone can contribute, and
thanks to Mercurial now it's even easier. With this talk I want to
unveil what happens &amp;quot;behind the scenes&amp;quot; of CPython and how you can get
involved and be part of the open source community that allows Python to
be one of the most popular programming languages.&lt;/p&gt;
&lt;p&gt;I will explain:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;what is the workflow of the CPython development;&lt;/li&gt;
&lt;li&gt;how to get a clone of Python;&lt;/li&gt;
&lt;li&gt;how to use Mercurial to do all the most common operations;&lt;/li&gt;
&lt;li&gt;what is the structure of the main CPython repository;&lt;/li&gt;
&lt;li&gt;what other are repositories are used;&lt;/li&gt;
&lt;li&gt;how to use the bug tracker to report and find bugs;&lt;/li&gt;
&lt;li&gt;how to use remote Mercurial repos to contribute code;&lt;/li&gt;
&lt;li&gt;what tools are used;&lt;/li&gt;
&lt;li&gt;how to get in touch with the core developers;&lt;/li&gt;
&lt;li&gt;what are the plans for the future.&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="community"></category><category term="contribute"></category><category term="cpython"></category><category term="mercurial"></category><category term="workflow"></category></entry><entry><title>Continuous deployment</title><link href="http://pyvideo.org/pycon-us-2011/pycon-2011--continuous-deployment.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Laurens Van Houtven</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--continuous-deployment.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Continuous deployment&lt;/p&gt;
&lt;p&gt;Presented by Laurens Van Houtven&lt;/p&gt;
&lt;p&gt;This talk is about continuous deployment practices and tools, lessons
learned from implementing it, and putting them into perspective. The
goal is to give other people tips and pointers for applying these ideas
themselves.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;Continuous deployment is the practice of putting the latest revision of
software into production use all the time, as opposed to working towards
larger releases. The important difference is iteration time: whereas
large software packages produce new software in timeframes of years or
months, continuous deployment teams typically put new code into
production in timeframes of hours or less.&lt;/p&gt;
&lt;p&gt;The practice is slowly attracting a small but growing group of loyal
followers, just like continuous integration over the past few years and
test- driven development did before that. They can be explained in terms
of being natural extensions of each other. Like TDD and CI, CD gets eyed
somewhat suspiciously (and rightfully so: skeptical analysis is great),
but the undersigned believes there's a legitimate advantage for many
applications.&lt;/p&gt;
&lt;p&gt;Many years ago, TTD and testing tools in general were mostly ad-hockery.
Now, with many different production-quality testing tools, this has
become unthinkable. Similarly, continuous integration was something
other people did for a long time, but now we have tools such as Buildbot
and Hudson. Continuous deployment is still somewhat in the early stage
in terms of ready-to-use tools, but it's likely that we'll see a similar
evolution.&lt;/p&gt;
&lt;p&gt;Here's a rough outline of what I plan to cover:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;a short history of people developed software&lt;/li&gt;
&lt;li&gt;from the recent models to CD (sort of a working definition of CD
here)&lt;/li&gt;
&lt;li&gt;when is it a good idea? pros/cons&lt;/li&gt;
&lt;li&gt;requirements &amp;amp; battle plan for applying CD in an existing development
environment (and possibly code base)&lt;/li&gt;
&lt;li&gt;an overview of existing tools and how they work together&lt;/li&gt;
&lt;li&gt;caveat emptors, known pitfalls (deployment and recovery strategies go
here, since most implementations figure out they need them after
stuff blows up)&lt;/li&gt;
&lt;li&gt;questions! (hopefully lots of people who've tried or are thinking
about implementing something similar -- like I said, there are a lot
of people implementing it but not too many ideas being bounced
around)&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="cd"></category><category term="ci"></category><category term="continuousdeployment"></category><category term="deployment"></category><category term="pycon"></category><category term="pycon2011"></category><category term="softwaredevelopment"></category><category term="tdd"></category><category term="workflow"></category></entry></feed>